<template>
  <div class="container">
    <b-form-group label="Prefix" description="Example, git">
      <b-form-input v-model="baseName"></b-form-input>
    </b-form-group>
    <div class="mt-2">
      <b-form-group label="Select SVG icons">
        <b-form-file
          accept="image/svg+xml"
          type="file"
          ref="file"
          @change="fileChange"
          multiple
        >
          <template slot="file-name" slot-scope="{ names }">
            <b-badge variant="dark">{{ names[0] }}</b-badge>
            <b-badge v-if="names.length > 1" variant="dark" class="ml-1">
              + {{ names.length - 1 }} More files
            </b-badge>
          </template>
        </b-form-file>
      </b-form-group>
      <b-row>
        <b-col
          v-for="(item, index) in files"
          :key="index"
          cols="3"
        >
          <b-card no-body class="mt-3">
            <template v-slot:header>
              <div class="d-flex align-items-center">
                <b-button-close class="mr-auto" variant="danger" @click="remove(item)">
                </b-button-close>
                <div class="ml-auto">
                  {{ baseName+ '-' + item.metadata.name }}
                </div>
              </div>
            </template>
            <div :class="baseName+ '-' + item.metadata.name" class="d-flex justify-content-center p-1" style="font-size: 3rem">
            </div>
          </b-card>
        </b-col>
      </b-row>
    </div>
    <b-form-group label="CSS Code" class="mt-3">
      <template v-slot:label>
        <div class="d-flex">
          <div class="mr-auto">CSS Code</div>
          <div class="ml-auto">
            <b-button @click="copy">Copy</b-button>
            <b-button class="ml-2" @click="download">Download</b-button>
          </div>
        </div>
      </template>
      <b-textarea refs="textarea" v-model="css" no-resize rows="10"/>
    </b-form-group>
  </div>
</template>
<script>
/* eslint-disable */
const Stream = require('stream').PassThrough
const FontBuilder = new (require('../assets/SvgFontBuilder'))();
export default {
  name: 'HomePage',
  metaInfo () {
    return {
      title: 'Icon Pack generator'
    }
  },
  data () {
    return {
      files: [],
      baseName: 'test',
      curCodePoint: 0xE001,
      svgFont: new Buffer(1)
    }
  },
  computed: {
    css () {
      let classes = ``
      classes += `[class*='${this.baseName}-']:before{font-family: '${this.baseName}'; display: inline-block; line-height: 1;box-sizing: border-box; font-style: normal;}`
      this.files.map((file, index) => {
        classes += `.${this.baseName}-${file.metadata.name}:before {content: '${file.metadata.unicode}';}`
      })
      const fontFamily = 'font-family:"' + this.baseName + '";';
      const src = 'src:url(data:font/woff;charset=utf-8;base64,' + new Buffer(this.svgFont).toString('base64') + ');';
      let attributes = [fontFamily, src]
      let fontFace = '@font-face{' + attributes.join('') + '}'
      document.getElementById('fontStyle').innerText = classes + fontFace
      return classes + fontFace
    }
  },
  mounted () {
  },
  methods: {
    copyInBuffer (str) {
      let tmp = document.createElement('INPUT') // Создаём новый текстовой input
      let focus = document.activeElement // Получаем ссылку на элемент в фокусе (чтобы не терять фокус)

      tmp.value = str // Временному input вставляем текст для копирования

      document.body.appendChild(tmp) // Вставляем input в DOM
      tmp.select() // Выделяем весь текст в input
      document.execCommand('copy') // Магия! Копирует в буфер выделенный текст (см. команду выше)
      document.body.removeChild(tmp) // Удаляем временный input
      focus.focus() // Возвращаем фокус туда, где был
    },
    copy() {
      this.copyInBuffer(this.css)
    },
    download() {
        let a = document.createElement("a");
        let file = new Blob([this.css + `\n/*Generated by sanek.dev IconFont*/`], {type: 'plain/text'})
        a.href = URL.createObjectURL(file)
        a.download =  this.baseName+ '.min.css'
        a.click()
    },
    remove (target) {
      this.files = this.files.filter(item => item.metadata.unicode !== target.metadata.unicode)
    },
    fileChange: function (e) {
      this.files = []
      this.curCodePoint = 0xE001
      const self = this
      let input, fr

      input = this.$refs.file.$refs.input
      input.files.forEach((item, index) => {
        perFile(input.files[index])
      })

      function perFile (file) {
        let matches = file.name.match(/^(?:u([0-9a-f]{4})\-)?(.*).svg$/i);
        let codepoint = (matches[1] ? parseInt(matches[1], 16) : self.curCodePoint++);
        let iconStream = new Stream()
        fr = new FileReader()
        fr.onload = (e) => {
          iconStream.write(e.target.result, 'utf8');
          iconStream.end();
        }
        fr.readAsText(file)

        iconStream.metadata = {
          unicode: [String.fromCharCode(codepoint)],
          name: matches[2]
        }
        self.files.push(iconStream)
      }

      FontBuilder.bundle(self.files, {
        fontName: self.baseName,
        normalize: true,
        fontHeight: 1000,
        descent: 0,
        fixedWidth: false,
      },  (result) => {
        this.svgFont = result.woff
      })
    }
  }
}
</script>
